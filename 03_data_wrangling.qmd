---
title: "Data Wrangling in R"
author: "Mathew Rogers Muyinda"
---

## Introduction

Data wrangling or data munging is the process of refining, reorganizing,
and converting raw data into a more useful and organized format that can
be analyzed. This step is the most time-consuming phase during data
analysis, as you will likely discover when working on your own projects.
You can read more about data wrangling
[here](https://online.hbs.edu/blog/post/data-wrangling).

In this chapter, we are going to rely heavily on the `BRFSS` dataset
introduced in the preceding chapter to demonstrate common data wrangling
tasks using the [`dplyr`](https://dplyr.tidyverse.org/index.html)
package. For operations that the `BRFSS` data cannot facilitate, we will
make utility of other datasets. `dplyr` is part of the popular and
versatile `tidyverse` meta-package comprising of several individual
packages that make data wrangling, visualization and modelling easy.

Let's load the packages we'll use in this chapter:

```{r}
#| label: load-session-packages

# load packages to be used in the chapter
librarian::shelf(
  rio,                         # importing and exporting data
  here,                        # finding files using relative directory
  tidyverse,                   # for data wrangling 
  DT,                          # interactive data tables
  janitor,                     # cleaning variable names
  expss, labelled, sjlabelled  # working with variable and value labels
  )
```

And, load/import the `BRFSS` dataset:

```{r}
#| label: import-brffss-dataset

# import BRFSS data
brfss <- import(here("data", "BRFSS2021.XPT"))
```

## Examining your data

It is helpful to first get a feel of your data and its structure before
delving into analysis. `R` has several options for this. When we
imported the `BRFSS` dataset, we saved it as an `R` object, `brfss`. All
objects in `R` have attributes which can be accessed using the `str()`
function.

```{r}
#| label: brfss-structure

# get overview of data structure
str(brfss)
```

The `str()` output tells us that `brfss` is of the `data.frame` class
with `r nrow(brfss)` rows and `r ncol(brfss)` columns. Also shown are
variable names, their types and labels as well as values of the first 10
observations for each variable.

You can access all the information from the `str()` output individually:

```{r}
#| label: data-dimensions

# brfss data dimensions (rows and columns)
dim(brfss)
```

```{r}
#| label: no-rows

# get number of rows in brfss dataset
nrow(brfss)
```

```{r}
#| label: no-cols

# get number of columns in brfss dataset
ncol(brfss)
```

```{r}
#| label: variable-names

# get all brfss variable names
colnames(brfss)
```

Applying the `class()` function over all variables using the `sapply()`
returns the class of all variables at once:

```{r}
#| label: variable-classes-sapply

# get class for all brfss variables
sapply(brfss, class)
```

Instead of using `sapply()`, the [`purrr`](https://purrr.tidyverse.org/)
package, part of the `tidyverse` provides an alternative in `map()`:

```{r}
#| label: variable-classes-map

# get class for all brfss variables (using map)
map(brfss, class)
```

To get the class of a single variable:

```{r}
#| label: class-gender

# get class of `_DRNKWK1` variable
class(brfss$`_DRNKWK1`)
```

To view the first 6 observations in a dataset:

```{r}
#| label: head-brfss

# get first 6 observations
head(brfss)
```

Specifying a value in `head()` returns that number of first observations
in the dataset. For instance, to get the first 3 observations:

```{r}
#| label: first-3-obs

# view first 9 observations 
head(brfss, 3)
```

To view a specified number of last observations in a dataset, use
`tail()`:

```{r}
#| label: tail-brfss

# get last 6 observations
tail(brfss)
#tail(brfss, 8) # last 8 observations
```

To get variable attributes, use `attributes()`: all variables in `brfss`
have a label attribute.

```{r}
#| label: attributes-all-variables

# get attributes of all variables
map(brfss, attributes)

# attributes(brfss$MARITAL): returns attributes for specified variable only
```

`dplyr::glimpse()` provides an alternative to `str()`. It's output is
more compact and easier to grasp. It, however, does not show variable
attributes.

```{r}
#| label: glimpse-brfss

# glimpse brfss dataset
glimpse(brfss)
```

For the classic spreadsheet view of your data in `RStudio`, you can use
`tibble::view()` (or base `R`'s `View()`:

```{r}
#| label: view-dataset
#| eval: false

# get spreadsheet view of brfss dataset in RStudio
tibble::view(brfss)
```

`DT::datatable()` enables an interactive spreadsheet view of a dataset:

```{r}
#| label: datatable-brfss

# get an interactive spreadsheet view of 100 random observations
brfss %>% 
  slice_sample(n = 100) %>% 
  datatable()
```

## Cleaning variable names

You should aim for good variable names by following these guidelines:

-   Use short descriptive names
-   Use lowercase
-   Variable names can contain only letters, numbers, periods and
    underscores.
-   Variable names can start with a letter but not with a number or an
    underscore
-   Use an underscore to separate words within a variable name
-   Avoid using existing `R` function names or keywords

The variable names in `brfss` violate several of the above guidelines.
We can rectify this use `clean_names()` from the `janitor` package.

```{r}
#| label: clean-variable-names

# clean variable names
brfss <- brfss %>% 
  clean_names()

# check new (clean) variable names
colnames(brfss)
```

`clean_names()` does a decent in this case but in some other cases, its
output might not be exactly what you wish. In this case, you may
consider renaming variables by hand using `rename()`. For example:

```{r}
#| label: rename-to-uppercase

# rename addepev3 and chckdny2 variables
brfss %>% 
  rename(
    # new name = old name
    "depressive_disorder" = addepev3,
    "kidney_disease" = chckdny2
  ) %>% 
  colnames()
```

You can rename variables using a function within `rename_with()`. If,
for example, we wanted to convert all variable names to uppercase:

```{r}
#| label: rename-with-tolower

# convert variable names to uppercase
brfss %>% 
  rename_with(toupper) %>% 
  colnames()
```

## Working with labels

Although short names are preferred, they may not be sufficient in
accurately representing meanings of variables. Variable (and value)
labels can provide detailed descriptions of the variables to ensure
clarity on what they represent. Using labels can prevent errors and
misunderstandings, and eliminate the need to switch between a codebook
and data, particularly when working with secondary datasets like the
`BRFSS` dataset. *It is worth noting that labels may not be supported by some base and other package functions, leading to unexpected behavior. In such cases, you may work primarily with the non-labelled dataset but keep a small subset of labelled data for reference.*


The [`expss`](https://cran.r-project.org/web/packages/expss/index.html),
[`sjlabelled`](https://cran.r-project.org/web/packages/sjlabelled/vignettes/intro_sjlabelled.html)
and
[`labelled`](https://cran.r-project.org/web/packages/labelled/vignettes/intro_labelled.html)
packages simplify working with labels in `R`.

### Variable labels

To view labels of all variables, you can use `labelled::var_label()`:

```{r}
#| label: get-variable-labels-labelled

# get variable labels
labelled::var_label(brfss)
```

For a more compact detailed view of variable labels, you can use
`labelled::look_for()`:

```{r}
#| label: view-brfss-var-labels

# view all variable labels
labelled::look_for(brfss)

#sjlabelled::get_label(brfss)
```

You can get the label for a single variable, using
`labelled::var_label()`:

```{r}
#| label: get-chckdny2-variable-label

# get label for chckdyn2
labelled::var_label(brfss$chckdny2)

#expss::var_lab(brfss$chckdny2)
#sjlabelled::get_label(brfss$chckdny2)
```

To remove a variable label(s):

```{r}
#| label: remove-chckdyn2
#| eval: false

# remove label for chckdny2
expss::drop_var_labs(brfss$chckdny2)
#labelled::var_label(brfss$chckdny2) <- NULL


# remove all labels from brfss
expss::drop_var_labs(brfss)
#labelled::var_label(brfss) <- NULL
```

Let's assign modified labels to variables in the `brfss` dataset using
`expss::apply_labels()`:

```{r}
#| label: add-variable-labels

# assign (new) labels to variables
brfss <- brfss %>% 
  apply_labels(
    age80     = "Age (years)",
    urbstat   = "Urban/Rural status",
    racegr3   = "Race",
    sex       = "Sex",
    marital   = "Marital status",
    htm4      = "Height (meters)",
    wtkg3     = "Weight (kg)",
    educag    = "Level of education completed",
    employ1   = "Employment status",
    incomg1   = "Total annual income",
    smoker3   = "Smoking status",
    rfsmok3   = "Current smoking",
    drnkwk1   = "Number of alcoholic beverages consumed per week",
    rfdrhv7   = "Heavy alcohol consumption",
    frutsu1   = "Total fruits consumed per day",
    vegesu1   = "Total vegetables consumed per day",
    frtlt1a   = "Consume fruits 1 or more times per day",
    veglt1a   = "Consume vegetables 1 or more times per day",
    totinda   = "Leisure time physical activity in last 30 days",
    genhlth   = "General health",
    rfhype6   = "High blood pressure",
    bpmeds    = "Currently taking blood pressure medication?",
    rfchol3   = "High cholesterol",
    cholmed3  = "Currently taking medicine for high cholesterol",
    michd     = "Ever reported having a coronary heart disease or myocardial infarction?",
    cvdstrk3  = "Ever diagnosed with stroke?",
    addepev3  = "Ever told you have a depressive disorder?",
    chckdny2  = "Ever told you have Kidney disease?",
    diabete4  = "Ever told you have diabetes?"
  )
```

Let's check our new assigned variable labels:

```{r}
#| label: check-new-brfss-variable-labels

# check new variable labels
look_for(brfss)
```

### Value labels

A glimpse of the `brfss` data showed values for all variables recoded as
numbers (e.g., 1, 2, 3). These values are not what expect for some
non-numeric variables like `gender`. These numbers represent categories
within those variables. Using `apply_labels()`, let's assign labels to
explicitly indicate what the values stand for.

```{r}
#| label: add-value-labels

# assign value labels
brfss <- brfss %>% 
  apply_labels(
    
    urbstat = c(
      "Urban" = 1, 
      "Rural" = 2
    ),
    
    racegr3 = c(
      "White" = 1, 
      "Black" = 2, 
      "Other" = 3, 
      "Multiracial" = 4, 
      "Hispanic" = 5
    ),
    
    sex = c(
      "Male" = 1, 
      "Female" = 2
    ),
    
    marital = c(
      "Married" = 1,
      "Divorced" = 2, 
      "Widowed" = 3, 
      "Separated" = 4,
      "Never married" = "5",
      "Unmarried couple" = 6
    ),
    
    educag = c(
      "Some high school" = 1, 
      "Graduated high school" = 2,
      "Some college/technical" = 3, 
      "Graduated college/technical" = 4
    ),
    
    employ1 = c(
      "Wages" = 1, 
      "Self-employed" = 2, 
      "No work, >= 1 year" = 3, 
      "No work, < 1 year" = 4, 
      "Homemaker" = 5, 
      "Student" = 6, 
      "Retired" = 7, 
      "Unable to work" = 8
    ),
    
    incomg1 = c(
      "Less than $15,000" = 1, 
      "$15,000 to < $25,000" = 2, 
      "$25,000 to < $35,000" = 3, 
      "$35,000 to < $50,000" = 4, 
      "$50,000 to < $100,000" = 5, 
      "$100,000 to < $200,000" = 6, 
      "$200,000 or more" = 7
    ), 
    
    smoker3 = c(
      "Current smoker, daily" = 1, 
      "Current smoker, occasional" = 2, 
      "Former smoker" = 3, 
      "Never smoked" = 4
    ),
    
    rfsmok3 = c(
      "No" = 1, 
      "Yes" = 2
    ),
    
    rfdrhv7 = c(
      "No" = 1, 
      "Yes" = 2
    ), 
    
    frtlt1a = c(
      ">= Once" = 1, 
      "< Once" = 2
    ),
    
    veglt1a = c(
      ">= Once" = 1, 
      "< Once" = 2
    ), 
    
    totinda = c(
      "Yes" = 1, 
      "No" = 2
    ), 
    
    genhlth = c(
      "Excellent" = 1, 
      "Very good" = 2, 
      "Good" = 3, 
      "Fair" = 4, 
      "Poor" = 5
    ),
    
    rfhype6 = c(
      "No" = 1, 
      "Yes" = 2
    ),
    
    bpmeds = c(
      "Yes" = 1, 
      "No" = 2
    ), 
    
    rfchol3 = c(
      "No" = 1, 
      "Yes" = 2
    ),
    
    cholmed3 = c(
      "Yes" = 1, 
      "No" = 2
    ),
    
    michd = c(
      "Yes" = 1, 
      "No" = 2
    ),
    
    cvdstrk3 = c(
      "Yes" = 1, 
      "No" = 2
    ),
    
    addepev3 = c(
      "Yes" = 1, 
      "No" = 2
    ),
    
    chckdny2 = c(
      "Yes" = 1, 
      "No" = 2
    ), 
    
    diabete4 = c(
      "Yes" = 1, 
      "Gestational" = 2, 
      "No" = 3, 
      "Pre/borderline" = 4)
  )
```

Let's look at all value labels:

```{r}
#| label: get-all-value-labels

# get all value labels
sjlabelled::get_labels(brfss)
```

To look at value labels for a single variable:

```{r}
#| label: value-labels-cvdstrk3

# get value labels for cvdstrk3
expss::val_lab(brfss$cvdstrk3)
#labelled::val_labels(brfss$cvdstrk3)
#sjlabelled::get_labels(brfss$cvdstrk3)
```

To drop value labels:

```{r}
#| label: drop-value-labels
#| eval: false

# drop all value labels
expss::drop_val_labs(brfss)

# drop value labels for a single variable
expss::drop_val_labs(brfss$genhlth)

```

## Selecting columns

`dplyr::select()` simplifies working with only a specific subset of
columns within a dataset. Note that when using `select()`, variables
will be returned in the specified order, and any variables that are not
included will be removed from the output.

### Positional selection

You can select variables using their position in a dataset:

```{r}
#| label: select-first-six-vars

# select first 6 columns
brfss %>% 
  select(1:6) %>% 
  glimpse()
```

```{r}
#| label: select-1-4-6-10-vars

# select first, fourth, sixth and tenth variables
brfss %>%
  select(1, 4, 6, 10) %>% 
  glimpse()
```

We can select variables by specifying their names, either quoted or
unquoted:

```{r}
#| label: select-racegr3-sex-michd-genhlth

# select racegr3, sex, michd and genhlth variables
brfss %>% 
  select(racegr3, sex, michd, genhlth) %>% 
  glimpse()
```


Using [`tidy selection`](https://dplyr.tidyverse.org/reference/dplyr_tidy_select.html),
you can select columns based on their names or properties. For instance,
to select the last column:


```{r}
#| label: select-last-col

# select last column
brfss %>%
  select(last_col()) %>% 
  head()
```

Select the 3rd last column:

```{r}
#| label: select-third-last-col

# select third last column
brfss %>%
  select(last_col(offset = 2L)) %>% 
  head()
```

### Tidy selection

You can select variables based on their data type. For example, to
select all numerical variables:

```{r}
#| label: select-num-cols

# select all numeric variables
brfss %>% 
  select(where(is.numeric)) %>% 
  glimpse()

# use is.factor for factors; is.character for character variables
```

You can select all (`all_of()`) or any (`any_of()`) variables whose
names are contained in an external character vector:

```{r}
#| label: select-any-vars-vector

# create vector with variable names
vec_1 <- c("names", "sex", "stroke", "racegr3", "educag", "residence")

# select any variable whose name is contained in vec_1
brfss %>%
  select(any_of(vec_1)) %>% 
  glimpse()
```

```{r}
#| label: select-all-vars-vector

# create vector with variable names
vec_2 <- c("sex", "age80", "urbstat", "marital")

# select all variables whose names match those in vec_2
brfss %>%
  select(all_of(vec_2)) %>% 
  glimpse()
```

You can select variables whose names contain specified
strings/characters:

```{r}
#| label: select-vars-contain-med

# select variables containing "med" string
brfss %>%
  select(contains("med")) %>% 
  glimpse()
```

```{r}
#| label: select-vars-starts-with-f

# select variables that with the "f" character
brfss %>%
  select(starts_with("f")) %>% 
  glimpse()
```

```{r}
#| label: select-vars-ends-with-1

# select all variables whose names end with "1"
brfss %>% 
  select(ends_with("1")) %>% 
  glimpse()
```

### Removing columns

You can exclude/remove columns by pre-pending a minus (-) sign to the
variable name:

```{r}
#| label: remove-wtkg3-htm4-vars

# de-select wtkg3 and htm4 variables
brfss %>% 
  select(-wtkg3, -htm4) %>% 
  glimpse()
```

```{r}
#| label: remove-wtkg3-htm4-tidy-select

# vector of variables to exclude
vars_rm <- c("wtkg3", "htm4")

# exclude all variables specified in vars_rm
brfss %>% 
  select(-all_of(vars_rm)) %>% 
  glimpse()
```

```{r}
#| label: remove-vars-contains-med

# remove variables whose names contain the "med" string 
brfss %>% 
  select(-contains("med")) %>% 
  glimpse()
```

## Subsetting rows

Having looked at how to select variables, let's now look at the various
ways of subsetting observations (or rows) from a dataset.

### Positional subsetting

`dplyr::slice()` provides several ways of subsetting rows based on their
position in a dataset.

To extract data for the first observation:

```{r}
#| label: slice-head

# get first row
brfss %>% 
  slice_head()
```

To extract data from the first 10 observations:

```{r}
#| label: slice-head-10

# get first 10 observations
brfss %>% 
  slice_head(n = 10)
```

To extract data for the last observation:

```{r}
#| label: slice-tail

# get last observations
brfss %>% 
  slice_tail()
```

To extract data for the last 5 observations:

```{r}
#| label: slice-tail-10

# get last 5 observations
brfss %>% 
  slice_tail(n = 5)
```

To extract data for the 1st, 3rd, 7th and 12th observations:

```{r}
#| label: slice-1-3-7-12

# get 1st, 3rd, 7th and 12th observations
brfss %>% 
  slice(c(1, 3, 7, 12))
```

To extract data for a random sample of observations:

```{r}
#| label: slice-sample-12

# get random sample of 5 observations
brfss %>% 
  slice_sample(n = 5)
```

You can extract data for observations based on values of another
variable. To extract data for the first 5 observations with the
*highest* values of total number of vegetables consumed per day:

```{r}
#| label: slice-max-vegesu1a

# five observations with the highest vegesu1
brfss %>% 
  slice_max(n = 5, order_by = vegesu1)
```

To extract data for the first 2 observations with the *lowest* values of
total number of vegetables consumed per day:

```{r}
#| label: slice-min-bmi

# get 2 observations with least vegesu1
brfss %>% 
  slice_min(n = 2, order_by = vegesu1)
```

### Conditional subsetting

Using `dplyr::filter()`, we can subset observations based on whether
they meet or do not meet specified conditions. To get observations aged
above 64 years:

```{r}
#| label: filter-above-64years

# get observations aged above 64 years
brfss %>% 
  filter(age80 > 64) %>% 
  head()
```

To get observations aged between 40 and 59 years:

```{r}
#| label: filter-between-40-59years

# get observations aged between 40 and 59 years
brfss %>% 
  filter(age80 >= 40 & age80 <= 59) %>% 
  head()
```

Alternatively:

```{r}
#| label: filter-between-40-59years-alternative

# get observations aged between 40 and 59 years
brfss %>% 
  filter(between(age80, 40, 59)) %>% 
  head()
```

To get observations aged either 18, 25, 30, 45, 50 or 60:

```{r}
#| label: filter-in-vector

# get observations aged either 18, 25, 30, 45, 50 or 60 years
brfss %>% 
  filter(age80 %in% c(18, 25, 30, 45, 50, 60)) %>% 
  head()
```

To get only male observations:

```{r}
#| label: filter-males

# get only male observations
brfss %>% 
  filter(sex == 1) %>% 
  head()
```

To get observations above 45 years *and* have ever had a diabetes
diagnosis:

```{r}
#| label: filter-above45-diabetes-dx

# get observations above 45 years and ever had a diabetes diagnosis
brfss %>% 
  filter(age80 > 45 & diabete4 == 1) %>% 
  head()
```

To get observations who are either on blood pressure *or* cholesterol
medications:

```{r}
#| label: filter-bpmeds-cholmeds

# get observations on blood pressure and high cholesterol medication
brfss %>% 
  filter(bpmeds == 1 | cholmed3 == 1) %>% 
  head(3)
```

To get all observations with missing data for weight (`wtkg3`):

```{r}
#| label: filter-missing-wtkg3

# get all observations with missing values for wtkg3
brfss %>% 
  filter(is.na(wtkg3)) %>% 
  tally() # counts the number of rows [alternative: sum(is.na(brfss$wtkg3))]
```

To get all observations without missing data for weight:

```{r}
#| label: filter-nonmissing-wtkg3

# get observations with non-missing data for wtkg3
brfss %>% 
  filter(!is.na(wtkg3)) %>% # '!' negates the condition
  tally()
```

## Re-ordering rows and columns

### Re-ordering rows

`dplyr::arrange()` is handy when it comes to changing order of
observations in a dataset. Let's arrange observation in order of
increasing number of alcoholic drinks consumed per week:

```{r}
#| label: arrange-drnkwk1-ascending

# arrange by drnkwk1 in ascending order
brfss %>% 
  arrange(drnkwk1) %>% 
  head(3)
```

To arrange observations in descending order of `drnkwk1`:

```{r}
#| label: arrange-drnkwk1-descending

# arrange by drnkwk1 in descending order
brfss %>% 
  arrange(desc(drnkwk1)) %>% 
  head(3)
```

`dplyr::arrange()` sorts character variables in alphabetical order.
Let's arrange observations from the `ggplot2::msleep` dataset by animal
name:

```{r}
#| label: arrange-msleep-name

# arrange name by alphabetical order
msleep %>% 
  arrange(name) %>% 
  slice_head(n = 20)
```

We can sort observations based on information from multiple variables.
Let's arrange observations from the `msleep` by animal name (`name`),
brain weight (`brainwt`) and total sleep (`sleep_total`):

```{r}
#| label: arrange-name-bodywt-sleep

# arrange by name, bodywt, and sleep_total
msleep %>% 
  select(name, brainwt, sleep_total) %>% 
  arrange(name, brainwt, sleep_total) %>% 
  head(n = 10)
```

### Re-ordering columns

`dplyr::relocate()` can be used to change order of columns in a dataset.
Let's relocate `michd` to the end of the dataset:

```{r}
#| label: relocate-michd-end

# relocate michd to end of dataset
brfss %>% 
  relocate(michd, .after = last_col()) %>% 
  glimpse()
```

Let's relocate `urbstat` to the front of the dataset:

```{r}
#| label: relocate-urbstat-front

# relocate urbstat to start of dataset
brfss %>% 
  relocate(urbstat) %>% 
  glimpse()
```

For more options, call `?relocate`. You can also specify positions for
new variables in the `mutate()` call.

## Converting variables to appropriate R data types/structures

When importing data into `R`, variables may be converted to data types
that do not correspond to the actual data they represent. You should
always pay attention to such discrepancies before going further with
your analysis. You can convert variable(s) to another data type using
the `as.` functions: `as.numeric()`, `as.integer()`, `as.factor()`,
`as.character()`, `as.logical()` etc.

## Working with factors

Categorical variables in `R` are represented using the `factor` data
type, where each unique category is referred to as a `level`. However,
when importing the `brfss` dataset, all variables were initially encoded
as integers, which is not a suitable representation for categorical
variables. To resolve this, we will convert categorical variables to
factors and illustrate how they can be modified using the
[`forcats`](https://forcats.tidyverse.org/) package, which is loaded
with the `tidyverse.`

### Converting to factors

While `forcats::as_factor()` and its base `R` alternatives (`factor()`,
and `as.factor()`) can convert variables to factors, any variable labels
will be lost during the conversion process. For labelled variables,
using `sjlabelled::as_factor()` will retain all label attributes.

You can convert variables to factors one-by-one:

```{r}
#| label: convert-sex-to-factor

# convert sex to factor
brfss %>% 
  mutate(
    sex_2 = sjlabelled::as_factor(sex), .after = sex
  ) %>% 
  pull(sex_2) %>% # extracts sex column/variable
  glimpse()
```


When working with ordinal categorical variables, we have to specify this
during our conversion to factor. If, for example, we wanted too convert
general health (`genhlth`) into an ordered factor:

```{r}
#| label: convert-genhlth-ord-factor

# convert genhlth into ordered factor
brfss %>% 
  mutate(
    genhlth_ord = factor(genhlth, ordered = TRUE)
  ) %>% 
  pull(genhlth_ord) %>% 
  unique() # extracts unique elements from an object

```

We can use `dplyr::across()` to convert all categorical variables into
factors in a single step:

```{r}
#| label: convert-categorical-to-factors

# create a vector with names of variables to convert
fct_vars <- c("urbstat", "racegr3", "sex", "marital", "employ1", "educag", 
              "incomg1", "smoker3", "rfsmok3", "rfdrhv7", "frtlt1a", "veglt1a",  
              "totinda", "genhlth", "rfhype6", "bpmeds", "rfchol3", "cholmed3", 
              "michd", "cvdstrk3", "addepev3", "chckdny2", "diabete4")

# convert all variables included in fct_vars to factors
brfss <- brfss %>% 
  mutate(across(all_of(fct_vars), sjlabelled::as_factor))

```

Let's check whether factor conversion was successful:

```{r}
#| label: check-factor-conversion-success

# check whether conversion was successful
map(brfss, class)
```

From the above output, our factor conversion was a success. For each
factor variable, we see its name, label and levels.

### Recoding factor levels

Earlier, we assigned value labels with `expss::apply_labels()` prior to
converting variables into factors. In cases where variables are already
factors, the `forcats::fct_recode()` function can be utilized to recode
levels accordingly.

We can, for instance, change level names for factors one-by-one:

```{r}
#| label: recode-rfdhrv7

# rename levels of rfdhrv7
brfss %>% 
  mutate(
    rfdrhv7 = fct_recode(
      rfdrhv7, 
      # new name = old name
      "Heavy drinker" = "Yes",
      "Not heavy drinker" = "No"
    )
  ) %>% 
  pull(rfdrhv7) %>% 
  levels()
```

Or, multiple factors in one step. Let's recode all `Yes` levels to
`AFFIRMATIVE` and `No` levels to `NEGATIVE`:

```{r}
#| label: recode-vars-at-once

# rename levels of multiple factors at once
brfss %>% 
  mutate(
    across(
      c(rfsmok3, rfdrhv7, rfhype6:diabete4), 
      ~fct_recode(., "AFFIRMATIVE" = "Yes", "NEGATIVE" = "No")
    )
  ) %>% 
  select(where(is.factor)) %>% 
  map(levels)
```

### Collapsing factor levels

You can combine factor levels into one using `forcats::fct_collapse()`.
Let's collapse levels for marital status (`marital`) and diabetes
(`diabete4`):

```{r}
#| label: collapse-marital-and-diabete4

# collapse marital and diabete4 levels
brfss <- brfss %>% 
  mutate(
    marital = fct_collapse(marital,
                           
      # new level = old levels to be collapsed
      "Married" = c("Married", "Unmarried couple"),
      "Ever married" = c("Divorced", "Widowed", "Separated")
    ),
    
    diabete4 = fct_collapse(diabete4,
      "No" = c("No", "Gestational", "Pre/borderline")
    )
  )

# check new levels
brfss %>% 
  select(marital, diabete4) %>% 
  map(levels)
```

### Re-ordering factor levels

`R` defaults to alphabetical ordering of factor levels, but you can
reorder them to your needs using `forcats::fct_relevel()`:

```{r}
#| label: change-factor-levels-manually

# reorder levels in smoker3 and racegr3 variables
brfss <- brfss %>% 
  mutate(
    smoker3 = fct_relevel(smoker3, "Never smoked"), # makes `Never smoked` the reference
    
    racegr3 = fct_relevel(racegr3, 
                          c("White", "Black", "Multiracial", "Hispanic", "Other"))
    # explicitly specify level order
  )


# check releveled factors
brfss %>% 
  select(smoker3, racegr3) %>% 
  map(levels)
```

You can also reorder levels of multiple factors at once:

```{r}
#| label: relevel-across-multiple-factors

# reorder levels of multiple factors such that 'No' is the reference
brfss <- brfss %>% 
  mutate(
    across(c(rfsmok3, rfdrhv7, totinda, rfhype6:diabete4), 
           ~fct_relevel(., "No"))
  )

# check new level order
brfss %>% 
  select(rfsmok3, rfdrhv7, totinda, rfhype6:diabete4) %>% 
  map(levels)
```

You can also change factor level order based on number of observations
in each level. We'll demonstrate this using smoking status (`smoker3`).
First, let's get the frequency of each level using `janitor::tabyl()`:

```{r}
#| label: check-smoker3-level-freq

# get level smoker3 frequencies
brfss %>% 
  tabyl(smoker3)
```

Now, let's reorder the levels according to frequency:

```{r}
#| label: reorder-smoker3-levels-by-freq

# reorder smoker3 levels based on frequency
brfss %>%
  mutate(
    smoker3 = fct_infreq(smoker3)
  ) %>% 
  tabyl(smoker3)
```

To reverse the default descending order to ascending using
`forcats::fct_rev()`:

```{r}
#| label: reorder-smoker3-levels-by-freq-ascending

# reorder smoker3 levels by frequency in ascending order
brfss %>%
  mutate(
    smoker3 = fct_rev(fct_infreq(smoker3))
  ) %>% 
  tabyl(smoker3)
```

You can reorder factor levels based on values in another variable. Let's
change order of `smoker3` levels using number of alcoholic drinks
consumed per week:

```{r}
#| label: reorder-smoker3-by-bmi

# reorder smoker3 levels by drnkwk1
brfss %>%
  mutate(
    smoker3 = fct_reorder(smoker3, drnkwk1)
  ) %>% 
  tabyl(smoker3)
```

The `forcats` package offers a lot more functions prefixed with `fct_`
for manipulating factors. A list of available functions can be obtained
by typing `?fct_` in the RStudio console.


## Transforming and computing new variables

Sometimes, you may wish to transform and/or create new variables from
existing variables in a dataset. All such operations are performed
within `dplyr::mutate()`.

### Modifying variables in place

Let's divide values of the `htm4`, `wtkg3`, `drnkwk1`, `frutsu1`, and
`vegesu1`variables by 100 to remove the 2 implied decimal places they
were entered with.

```{r}
#| label: glimpse-select-variables

# glimpse selected variables
brfss %>% 
  select(htm4, wtkg3, drnkwk1, frutsu1) %>% 
  glimpse()
```

```{r}
#| label: divide-by-100

# create vector with variable names
implied_2dp <- c("htm4", "wtkg3", "drnkwk1", "frutsu1", "vegesu1")

# divide selected variables by 100
brfss <- brfss %>% 
  mutate(
    across(all_of(implied_2dp), ~.x / 100)
  )

# check whether transformation was successful
glimpse(select(brfss, all_of(implied_2dp)))
```

### Creating new variables

We will now compute a `bmi` variable, representing the respondent's body
mass index (BMI), which is calculated as the weight in kilograms divided
by the square of the height in meters:
$BMI = \frac{weight (kg)}{height (m)^2}$.

```{r}
#| label: compute-bmi-variable

# compute BMI 
brfss <- brfss %>% 
  mutate(
    bmi = round(wtkg3 / htm4 ^ 2, 1), # calculates BMI rounded off to 1 dp
    .after = wtkg3 # places new variable after wtkg3
  )

# assign label to bmi variable
var_lab(brfss$bmi) = "Body mass index (kg/m^2)"
```

### Continuous to Categorical variable

#### Dichotomous variable

Sometimes, you may wish to transform a continuous variable into a
categorical variable. To create a dichotomous variable,
`dplyr::if_else()` takes a conditional statement, where the first value
is returned if the condition is true, and the second value is returned
if the condition is false. Let's create a new variable,
`overweight_obese` which indicates whether a person has a BMI of 25 or
greater, which is considered overweight or obese.

```{r}
#| label: create-overweight-obesity-variable

# create dichotomous overweight or obese indicator variable
brfss <- brfss %>% 
  mutate(
    overweight_obese = if_else(bmi >= 25, "Yes", "No"),
    .after = bmi
  ) %>% 
  mutate(
    overweight_obese = as_factor(overweight_obese),
    overweight_obese = fct_relevel(overweight_obese, "No")
  )

# assign a label to the new variable
var_lab(brfss$overweight_obese) = "Overweight or obese indicator"
```

#### Polytomous variable

To transform a continuous variable into a polytomous variable (with more
than 2 categories), you can use `dplyr::case_when()`. Let' create a
variable for BMI classification.

```{r}
#| label: create-BMI-categories

# create BMI classification variable
brfss <- brfss %>% 
  mutate(
    bmi_cat = as_factor(
      case_when(
        bmi < 18.5 ~ "Underweight",
        between(bmi, 18.5, 24.9) ~ "Normal",
        between(bmi, 25, 29.9) ~ "Overweight",
        between(bmi, 30, 34.9) ~ "Obese I",
        between(bmi, 35, 39.9) ~ "Obese II",
        bmi > 40 ~ "Obese III"
      )
    ),
    
    .after = bmi
  ) %>% 
  mutate(
    bmi_cat = fct_relevel(bmi_cat, 
                          c("Underweight", "Normal", "Overweight", 
                            "Obese I", "Obese II", "Obese III"))
  )

# assign variable label
var_lab(brfss$bmi_cat) <- "BMI classification"
```

### Row-wise operations

`dplyr::rowwise()` and `dplyr::c_across()` simplify the process of
performing row-wise operations on a data frame. As an example, let's
consider a hypothetical scenario where we need to create a new variable,
`mean_age_bmi`, that represents the mean of a respondent's age and BMI.

```{r}
#| label: rowwise-computation-1

# compute mean of age and BMI (rowwise)
brfss %>% 
  rowwise() %>% 
  mutate(
    mean_age_bmi = mean(c(age80, bmi)),
    .keep = "used" # keeps only input and output used in your manipulation
  ) %>% 
  head(3)
```

If we omitted the `rowwise()` function in the above code, we would get
unexpected results:

```{r}
#| label: incorrect-rowwise

# compute mean of age and BMI (without rowwise)
brfss %>% 
  mutate(
    mean_age_bmi = mean(c(age80, bmi), na.rm = TRUE),
    .keep = "used"
  ) %>% 
  head(3)
```

Sometimes, you may wish to perform row-wise operations on columns with a
common characteristic. Here, you can use the `dplyr::c_across()` which
supports tidy selection. For example, let's create a new variable,
`sum_all_num`, which represents the sum of all numerical variables in
the `brfss` dataset. Note that since `c_across()` does not support
labels which necessitates removing them before computation.

```{r}
#| label: rowwise-dplyr

# compute sum of all numerical variables
brfss %>% 
  slice_head(n = 100) %>% 
  drop_all_labels() %>% # drops all variable and value labels
  rowwise() %>% 
  mutate(
    sum_all_num = sum(
      c_across(where(is.numeric)), na.rm = TRUE) 
  ) %>% 
  select(where(is.numeric)) %>% 
  head(3)
```

Base `R` has row-wise summary functions which are much faster than
`dplyr` and support labels:

```{r}
#| label: rowwise-base-dplyr-hybrid

# compute sum of all numerical variables (base R rowSums)
brfss %>% 
  select(where(is.numeric)) %>% 
  mutate(
    sum_all_num = rowSums(across(where(is.numeric)), na.rm = TRUE)
  ) %>% 
  select(where(is.numeric)) %>% 
  head(3)
```

## Working with groups within data

`dplyr::group_by()` divides a dataset's observations into groups defined
by, often, a factor variable, after which all subsequent functions will
operate on by the grouping variable. To group by `brfss` by sex:

```{r}
#| label: group-by-demo

# group brfss by sex
brfss %>% 
  group_by(sex) %>% 
  head(10)
```

A common utility of `group_by()` is computation of summary statistics
using `summarise()` for groups. For instance, let's compute the average
BMI grouped by sex:

```{r}
#| label: mean-bmi-sex

# compute average BMI by sex
brfss %>% 
  group_by(sex) %>% 
  summarise(
    avg_bmi = mean(bmi, na.rm = TRUE)
  )
```

If we run the same code without `group_by()`, we get a column containing
the average BMI for all respondents:

```{r}
#| label: mean-bmi-overall

# compute average BMI for all respondents
brfss %>% 
  mutate(
    avg_bmi = mean(bmi, na.rm = TRUE),
    .keep = "used"
  ) %>% 
  head(3)
```

We can group by more than one variable and compute many summary
statistics in one `summarise()` call too.

```{r}
#| label: more-grouped-ops

# group by sex and michd and compute several summary stats
brfss %>% 
  drop_na(bmi, michd) %>% # drop all NA's from the bmi and michd variables 
  group_by(sex, michd) %>% 
  summarise(
    nobs = n(), # counts number of rows
    avg_bmi = mean(bmi), 
    sd_bmi = sd(bmi) # computes standard deviation
  )
```

Let's compute the median of all numeric variables in `brfss` by sex:

```{r}
#| label: tidy-select-grouped

# compute median value of all numeric variables by sex
brfss %>% 
  drop_na(where(is.numeric)) %>% 
  group_by(sex) %>% 
  summarise(
    across(where(is.numeric), median)
  )
```

Operations other than summmary statistics can be performed on grouped
datasets. For instance:

```{r}
# get 2 observations with the highest BMI by gender
brfss %>% 
  group_by(sex) %>% 
  slice_max(bmi, n = 2) %>% 
  select(sex, bmi)
```

```{r}
# observations bmi < 18.5 in order of increasing bmi by gender
brfss %>% 
  group_by(sex) %>% 
  filter(bmi < 18.5) %>% 
  slice_min(n = 3, order_by = bmi) %>% 
  select(sex, bmi) %>% 
  head()
```

```{r}
brfss %>% 
  drop_na(overweight_obese) %>% 
  group_by(overweight_obese) %>% 
  filter(drnkwk1 > 1 & drnkwk1 != 999) %>% 
  arrange(desc(drnkwk1)) %>% 
  select(overweight_obese, drnkwk1) %>% 
  head()
```

## Recoding missing values

Identifying and dealing with missing values early on is essential to
avoid unexpected results and/or errors later on during analysis. `R`
stores missing values as `NA`. Here, we look at some of the simplest
ways to recode `NA`'s.

For factor variables, you can use `fct_recode()` to recode levels to
missing values (i.e., `NA`). Let's recode the `7` and `9` which
represent refused/don't know/not sure responses.

```{r}
#| label: first-check-factor-levels

# check for all factor levels
brfss %>% 
  select(where(is.factor)) %>% 
  map(levels)
```

```{r}
#| label: recode-9-and7-to-NA

# recode all '7' and '9' values in all factor variables to NA
brfss <- brfss %>% 
  mutate(
    across(where(is.factor), ~fct_recode(., NULL = "7", NULL = "9"))
  ) 

# re-check factor levels
brfss %>% 
  select(where(is.factor)) %>% 
  map(levels)
```

Since we are working with factors, the numbers representing levels are
not actual numeric values, thus, we use quotation marks to specify them
as doing otherwise would through errors:

```{r}
#| label: throw-factor-level-error
#| error: true

# throw an error with unquoted factor levels
brfss %>% 
  mutate(
    across(where(is.factor), ~fct_recode(., NULL = 7, NULL = 9))
  ) 
```

For numeric variables, `dplyr::na_if()` converts specified values to
`NA`. Let's recode the `999` values that represent
`don't know/not sure/refused` responses in `drnkwk1` to `NA`:

```{r}
#| label: summary-drnkwk1

# run quick summary of drnkwk1 variable
summary(brfss$drnkwk1)
```

`dplyr::na_if()` is, however, incompatible with labels so we opt for the
similar label-compatible `expss::na_if()`:

```{r}
#| label: recode-999-NA-expss

# recode 999 as NA
brfss <- brfss %>% 
  mutate(
    across(drnkwk1, ~expss::na_if(., 999))
  ) 

# re-run summary
summary(brfss$drnkwk1)
```

[`naniar`](https://cran.r-project.org/web/packages/naniar/index.html)
offers an awesome alternative functions to recode missing values.
Details can be found in this
[vignette](http://naniar.njtierney.com/articles/replace-with-na.html)

If you wish to continue using labels, you can just re-assign them:
  
```{r}
#| label: re-assign-var-labels

# re-assign variable labels
brfss <- brfss %>% 
  apply_labels(
    age80 = "Age (years)",
    urbstat   = "Urban/Rural status",
    racegr3   = "Race",
    sex       = "Sex",
    marital   = "Marital status",
    educag    = "Highest education level completed",
    bmi_cat   = "BMI classification",
    overweight_obese = "Overweight/obesity indicator",
    employ1   = "Employment status",
    incomg1   = "Total annual income",
    smoker3   = "Smoking status",
    rfsmok3   = "Current smoking status",
    drnkwk1   = "Number of alcoholic beverages consumed per week",
    rfdrhv7   = "Heavy drinker",
    frutsu1   = "Total fruits consumed per day",
    vegesu1   = "Total vegetables consumed per day",
    frtlt1a   = "Consume fruits one or more times per day",
    veglt1a   = "Consume vegetables one or more times per day",
    totinda   = "Leisure time physical activity during past 30 days",
    genhlth   = "General health rating",
    rfhype6   = "Hypertension diagnosis",
    bpmeds    = "Currently taking medicine for high blood pressure",
    rfchol3   = "High cholesterol diagnosis",
    cholmed3  = "Currently taking medicine for cholesterol",
    michd     = "Ever had coronary heart disease or myocardial infarction?",
    cvdstrk3  = "Ever diagnosed with a stroke?",
    addepev3  = "Ever told you have a depressive disorder?",
    chckdny2  = "EVer told you have Kidney disease?",
    diabete4  = "Ever told you had diabetes?"
  )

# check variable labels after re-assignment
look_for(brfss)
```

At this stage, we have a fairly polished version of the `brfss` dataset.
Let's export it for use in subsequent chapters:

```{r}
#| label: export-wrangled-BRFSS-dataset

# export wrangled brfss dataset
export(brfss, here("data", "brfss_2021_clean.rds"))
```

## Tidy data

In a nutshell, *tidy* data has three fundamental properties: (1) each
column represents a distinct variable; (2) each row corresponds to a
unique observation; and (3) each cell contains only a single value. For
details on tidy data, refer to this
[article](https://www.jstatsoft.org/article/view/v059i10). In this
section, we use the [`tidyr`](https://tidyr.tidyverse.org/) package to
tidy data.

### Wide to long

In this section, we will use the [NCD Risk Factor Collaboration
(NCD.RisC)](https://ncdrisc.org/data-downloads-adiposity-urban-rural.html)
data on trends in age-standardized average adult body mass index (BMI)
for men and women residing in rural and urban areas across all countries
from 1985 to 2017. An overview of the data shows it's in a wide, or
*untidy* format because variables are dispersed across multiple columns,
whereas tidy data mandates that we have one variable per column.

```{r}
#| label: import-ncdrisc-data

# import data
bmi_trends <- import(here("data", "rural_urban_adult_bmi.csv"))

# view first 6 observations
head(bmi_trends)
```

To convert the data into a long `tidy` format in which we have a single
column for each of `bmi`, `lower_ci` and `upper_ci`, we use
`tidyr::pivot_longer()`:

```{r}
#| label: bmi-trends-to-long

# pivot data to long format
bmi_trends_long <- bmi_trends %>% 
  pivot_longer(
    cols = c(mean_bmi_urban, mean_bmi_rural),
    names_to = "residence",
    values_to = "bmi"
  )

glimpse(bmi_trends_long) # bmi is now in one column
```

`pivot_longer()` by default converts the column supplied to `names_to =`
to a character type. We can convert it to a factor using the
`names_transform` parameter:

```{r}
#| label: names-transform-demo

# convert names_to variable to factor
bmi_trends_long <- bmi_trends %>% 
  pivot_longer(
    cols = c(mean_bmi_urban, mean_bmi_rural),
    names_to = "residence",
    names_transform = list(residence = as.factor),
    values_to = "bmi"
  )

glimpse(bmi_trends_long)
```

Looking at the new `residence` variable, the values contain a prefix
`mean_bmi_` which isn't either rural or urban residence. To remove this,
we use the `names_prefix` argument:

```{r}
#| label: remove-names-prefix

# remove mean_bmi prefix
bmi_trends_long <- bmi_trends %>% 
  pivot_longer(
    cols = c(mean_bmi_urban, mean_bmi_rural),
    names_to = "residence",
    names_transform = list(residence = as.factor),
    names_prefix = "mean_bmi_",
    values_to = "bmi"
  )

glimpse(bmi_trends_long)
```

We still have 4 columns for the 95% confidence intervals. Let's go on to
pivot these into a long format with lower bounds in one column and upper
bounds in another distinct column:

```{r}
#| label: pivot-lowerci-long

# put lower confidence intervals in one column
bmi_trends_long <- bmi_trends_long %>% 
  pivot_longer(
    cols = c(urban_lower_ci, rural_lower_ci),
    names_to = "confidence_interval",
    names_transform = list(confidence_interval = as.factor),
    values_to = "lower_ci"
  )
```

```{r}
#| label: pivot-upperci-long

# put upper confidence intervals in one column
bmi_trends_long <- bmi_trends_long %>% 
  pivot_longer(
    cols = c(urban_upper_ci, rural_upper_ci),
    names_to = "confidence_interval2",
    names_transform = list(confidence_interval = as.factor),
    values_to = "upper_ci"
  )

glimpse(bmi_trends_long)
```

We can drop the 2 `confidence_interval` columns, to get a final tidier
dataset:

```{r}
#| label: drop-ci-cols

# get final tidy dataset
bmi_trends_long <- bmi_trends_long %>% 
  select(country, year, sex, residence, bmi, lower_ci, upper_ci)

glimpse(bmi_trends_long)
```

### Long to wide

We'll use a (contrived) dataset with measurements taken at three
intervals to demonstrate how to pivot data from long to wide format.

```{r}
#| label: import-dataset

# import dataset
long_data <- import(here("data", "long_data.csv"))

glimpse(long_data)
```

```{r}
#| label: pivot-longdata-wide

# pivot data to wide format
wide_data <- long_data %>% 
  pivot_wider(
    names_from = time,
    values_from = measurement
  )

glimpse(wide_data)
```

### Separating columns

Sometimes, you have a dataset in which two separate pieces of
information are contained in one column. You could separate the data
into separate columns using `dplyr::separate()`. For this example, we'll
digress from health data to a *Country music* (yeah!) dataset that
comprises 100 artist names, their birth dates, and one song title (taken
from a personal favorite playlist).

```{r}
#| label: import-country-artists-data

# import data
country_artists <- import(here("data", "country_artists.csv"))

country_artists
```

Let's separate the first and last names in the `name` column into
separate columns:

```{r}
#| label: separate-name-col

# separate name column
country_sep <- country_artists %>% 
  separate(
    name, # name of column you want to separate
    into = c("first_name", "last_name") # names of columns to hold separated data
  )

country_sep
```

### Uniting columns

Conversely, you can combine data from different columns into one. Let's
combine the `birth_year`, `birth_month` and `birth_day` columns into one
using `dplyr::unite()`:

```{r}
#| label: unite-birthdate-cols

# unite birth day columns
country_united <- country_sep %>% 
  unite(
    col = birth_date, # name of new column to hold all information
    c(birth_year, birth_month, birth_day), # columns from which to extract info
    sep = "-" # specify how you want the data to be separated
  )

country_united
```

We now have one column, `birth_date` containing all birth day
information of each artist. We convert this variable into the
appropriate date format using `lubridate::ymd()`. This function comes
from the
[`lubridate`](https://cran.r-project.org/web/packages/lubridate/vignettes/lubridate.html)
package which simplifies working with date and time data.

```{r}
#| label: convert-to-date

# convert birth date into date format
country_united %>% 
  mutate(
    d.o.b = lubridate::ymd(birth_date), .after = birth_date
  ) %>% 
  glimpse()
```

## Afterword

We have explored common data wrangling tasks but much more has not been
covered. There are innumerable free resources online for learning `R`
and data wrangling. For more on `tidyverse`-focused data wrangling, I
recommend starting from
[here](https://r4ds.hadley.nz/data-transform.html) and
[here](https://jhudatascience.org/tidyversecourse/wrangle-data.html).

`dplyr` is a versatile data wrangling package, easy-to-learn due to its user-friendly syntax but it can be slow when processing large datasets. For fast data wrangling, options include 
[`data.table`](https://rdatatable.gitlab.io/data.table/index.html), [`collapse`](https://sebkrantz.github.io/collapse/index.html), and  [`arrow`](https://arrow.apache.org/docs/r/articles/data_wrangling.html).
[`dtplyr`](https://dtplyr.tidyverse.org/) and
[`tidytable`](https://markfairbanks.github.io/tidytable/) harness the speed of `data.table` while while using `dplyr` syntax. Although not optimised for speed, [`datawizard`](https://easystats.github.io/datawizard/) provides alternative intuitive syntax for data wrangling.


I hope this chapter has provided you with the skills to start wrangling
data in `R` using `dplyr` and has pointed you to other available package
options for faster performance (or different syntax) as well as other
resources that may be of use. Happy data wrangling in `R`!
